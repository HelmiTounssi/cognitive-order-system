#!/usr/bin/env python3
"""
Script de test pour les am√©liorations d'extraction d'entit√©s
Teste les nouveaux patterns regex et l'extraction LLM de fallback
"""

import sys
import os
import re
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from src.knowledge_base import KnowledgeBase
from src.vector_store import VectorStore
from src.llm_interface import LLMInterface
from src.agent import CognitiveOrderAgent


def test_entity_extraction():
    """Test des am√©liorations d'extraction d'entit√©s"""
    
    print("üß™ Test des am√©liorations d'extraction d'entit√©s")
    print("=" * 60)
    
    # Initialisation des composants
    kb = KnowledgeBase()
    vs = VectorStore()
    
    # Test avec et sans LLM
    llm_interface = LLMInterface() if os.getenv('OPENAI_API_KEY') else None
    
    agent = CognitiveOrderAgent(kb, vs, llm_interface)
    
    # Cas de test pour l'extraction d'entit√©s
    test_cases = [
        # Tests de noms de clients
        {
            "query": "Cr√©er une commande pour Jean Dupont",
            "expected": {"client_name": "Jean Dupont", "intent": "create_order"}
        },
        {
            "query": "Le client Marie Martin veut commander 2 ordinateurs",
            "expected": {"client_name": "Marie Martin", "intent": "create_order"}
        },
        {
            "query": "Commande pour Pierre Durand avec 3 souris",
            "expected": {"client_name": "Pierre Durand", "intent": "create_order"}
        },
        
        # Tests de produits et quantit√©s
        {
            "query": "Je veux 5 unit√©s de clavier m√©canique",
            "expected": {"intent": "create_order", "products": [{"product_name": "clavier m√©canique", "quantity": 5}]}
        },
        {
            "query": "Commander 2 √©crans 4K avec 1 unit√© de support",
            "expected": {"intent": "create_order", "products": [{"product_name": "√©crans 4K", "quantity": 2}, {"product_name": "support", "quantity": 1}]}
        },
        {
            "query": "Je veux 3 souris gaming et 2 claviers",
            "expected": {"intent": "create_order", "products": [{"product_name": "souris gaming", "quantity": 3}, {"product_name": "claviers", "quantity": 2}]}
        },
        
        # Tests de montants
        {
            "query": "Payer 150,50 ‚Ç¨ pour la commande A-123",
            "expected": {"amount": "150,50", "order_id": "A-123", "intent": "process_payment"}
        },
        {
            "query": "Montant de 299.99 euros pour les accessoires",
            "expected": {"amount": "299.99", "intent": "process_payment"}
        },
        
        # Tests d'emails et t√©l√©phones
        {
            "query": "Ajouter le client Paul avec email paul@example.com",
            "expected": {"client_name": "Paul", "email": "paul@example.com", "intent": "add_client"}
        },
        {
            "query": "Nouveau client Sophie t√©l√©phone 06.12.34.56.78",
            "expected": {"client_name": "Sophie", "phone": "06.12.34.56.78", "intent": "add_client"}
        },
        
        # Tests de recommandations
        {
            "query": "Recommande moi des accessoires pour ordinateur",
            "expected": {"query_text": "accessoires pour ordinateur", "intent": "recommend_products"}
        },
        {
            "query": "Sugg√®re des produits similaires √† souris gaming",
            "expected": {"reference_product": "souris gaming", "intent": "recommend_products"}
        },
        
        # Tests de statut
        {
            "query": "V√©rifier le statut de la commande A-456",
            "expected": {"order_id": "A-456", "intent": "check_status"}
        },
        {
            "query": "O√π en est ma commande ?",
            "expected": {"intent": "check_status"}
        }
    ]
    
    print(f"üìã Test de {len(test_cases)} cas d'extraction d'entit√©s")
    print(f"ü§ñ LLM disponible: {'Oui' if llm_interface else 'Non'}")
    print()
    
    success_count = 0
    total_tests = len(test_cases)
    
    for i, test_case in enumerate(test_cases, 1):
        query = test_case["query"]
        expected = test_case["expected"]
        
        print(f"üß™ Test {i}/{total_tests}: {query}")
        
        try:
            # Test d'extraction d'intention
            intent = agent._extract_intent(query)
            print(f"  üéØ Intention d√©tect√©e: {intent}")
            
            # Test d'extraction de param√®tres
            params = agent._extract_parameters(query, intent)
            print(f"  üìã Param√®tres extraits: {params}")
            
            # V√©rification des r√©sultats
            intent_match = intent == expected.get("intent", "unknown")
            
            # V√©rification des param√®tres cl√©s
            param_matches = 0
            total_expected_params = 0
            
            for key, expected_value in expected.items():
                if key != "intent":
                    total_expected_params += 1
                    if key in params:
                        if key == "products":
                            # V√©rification sp√©ciale pour les produits
                            if isinstance(expected_value, list) and isinstance(params[key], list):
                                if len(expected_value) == len(params[key]):
                                    param_matches += 1
                        else:
                            # V√©rification simple pour les autres param√®tres
                            if str(params[key]).lower() == str(expected_value).lower():
                                param_matches += 1
            
            success_rate = param_matches / max(total_expected_params, 1)
            
            if intent_match and success_rate >= 0.7:
                print(f"  ‚úÖ Succ√®s: Intention correcte, {param_matches}/{total_expected_params} param√®tres corrects")
                success_count += 1
            else:
                print(f"  ‚ùå √âchec: Intention {'correcte' if intent_match else 'incorrecte'}, {param_matches}/{total_expected_params} param√®tres corrects")
            
        except Exception as e:
            print(f"  ‚ùå Erreur: {e}")
        
        print()
    
    # R√©sultats finaux
    success_rate = success_count / total_tests
    print("=" * 60)
    print(f"üìä R√©sultats finaux: {success_count}/{total_tests} tests r√©ussis ({success_rate:.1%})")
    
    if success_rate >= 0.8:
        print("üéâ Excellent! L'extraction d'entit√©s fonctionne tr√®s bien.")
    elif success_rate >= 0.6:
        print("‚úÖ Bon! L'extraction d'entit√©s fonctionne correctement.")
    else:
        print("‚ö†Ô∏è Am√©lioration n√©cessaire pour l'extraction d'entit√©s.")
    
    return success_rate


def test_llm_fallback():
    """Test sp√©cifique de l'extraction LLM de fallback"""
    
    if not os.getenv('OPENAI_API_KEY'):
        print("‚ö†Ô∏è Test LLM fallback ignor√© (OPENAI_API_KEY non d√©fini)")
        return
    
    print("\nü§ñ Test de l'extraction LLM de fallback")
    print("=" * 60)
    
    kb = KnowledgeBase()
    vs = VectorStore()
    llm_interface = LLMInterface()
    agent = CognitiveOrderAgent(kb, vs, llm_interface)
    
    # Cas de test complexes pour LLM
    complex_cases = [
        "Je souhaite commander pour mon ami Thomas qui habite √† Lyon, 3 unit√©s de ce super √©cran 4K que j'ai vu hier",
        "Pouvez-vous ajouter ma coll√®gue Sophie Dubois avec son email sophie.dubois@entreprise.fr et son portable 06 78 90 12 34",
        "J'ai besoin de recommandations pour des accessoires de bureau, quelque chose de moderne et ergonomique",
        "Combien co√ªte la livraison express pour ma commande du 15 mars dernier ?"
    ]
    
    for i, query in enumerate(complex_cases, 1):
        print(f"üß™ Test LLM {i}: {query}")
        
        try:
            intent = agent._extract_intent(query)
            params = agent._extract_parameters(query, intent)
            
            print(f"  üéØ Intention: {intent}")
            print(f"  üìã Param√®tres: {params}")
            
            # Test de l'extraction LLM de fallback
            llm_params = agent._extract_with_llm_fallback(query, intent)
            print(f"  ü§ñ LLM fallback: {llm_params}")
            
        except Exception as e:
            print(f"  ‚ùå Erreur: {e}")
        
        print()


def test_pattern_robustness():
    """Test de robustesse des patterns regex"""
    
    print("\nüîß Test de robustesse des patterns regex")
    print("=" * 60)
    
    kb = KnowledgeBase()
    vs = VectorStore()
    agent = CognitiveOrderAgent(kb, vs, None)  # Sans LLM pour tester uniquement les patterns
    
    # Tests de variations de texte
    variations = [
        # Variations de noms avec accents
        ("Commande pour Fran√ßois", "Fran√ßois"),
        ("Client Jos√© Mar√≠a", "Jos√© Mar√≠a"),
        ("Nouveau client Andr√©", "Andr√©"),
        
        # Variations de quantit√©s
        ("5 unit√©s de clavier", "5"),
        ("3 pi√®ces de souris", "3"),
        ("2 exemplaires d'√©cran", "2"),
        
        # Variations de montants
        ("150,50 ‚Ç¨", "150,50"),
        ("299.99 euros", "299.99"),
        ("Prix 45,00", "45,00"),
        
        # Variations d'emails
        ("email: test@example.com", "test@example.com"),
        ("courriel user.name@domain.co.uk", "user.name@domain.co.uk"),
        
        # Variations de t√©l√©phones
        ("06.12.34.56.78", "06.12.34.56.78"),
        ("06 12 34 56 78", "06 12 34 56 78"),
        ("06-12-34-56-78", "06-12-34-56-78")
    ]
    
    success_count = 0
    total_tests = len(variations)
    
    for query, expected in variations:
        print(f"üß™ Test: {query}")
        
        try:
            # Test avec les patterns d'entit√©s
            found = False
            for param_name, patterns in agent.entity_patterns.items():
                for pattern in patterns:
                    match = re.search(pattern, query, re.IGNORECASE)
                    if match:
                        value = match.group(1).strip()
                        if value.lower() == expected.lower():
                            print(f"  ‚úÖ Trouv√©: {param_name} = {value}")
                            found = True
                            success_count += 1
                            break
                if found:
                    break
            
            if not found:
                print(f"  ‚ùå Non trouv√©: attendu {expected}")
                
        except Exception as e:
            print(f"  ‚ùå Erreur: {e}")
        
        print()
    
    success_rate = success_count / total_tests
    print(f"üìä Robustesse des patterns: {success_count}/{total_tests} ({success_rate:.1%})")
    
    return success_rate


if __name__ == "__main__":
    print("üöÄ D√©marrage des tests d'extraction d'entit√©s am√©lior√©es")
    print()
    
    # Test principal d'extraction d'entit√©s
    main_success = test_entity_extraction()
    
    # Test de robustesse des patterns
    pattern_success = test_pattern_robustness()
    
    # Test LLM fallback
    test_llm_fallback()
    
    print("\n" + "=" * 60)
    print("üìã R√©sum√© des tests")
    print(f"  ‚Ä¢ Extraction d'entit√©s: {main_success:.1%}")
    print(f"  ‚Ä¢ Robustesse des patterns: {pattern_success:.1%}")
    print(f"  ‚Ä¢ LLM fallback: {'Test√©' if os.getenv('OPENAI_API_KEY') else 'Non test√©'}")
    
    if main_success >= 0.7 and pattern_success >= 0.8:
        print("\nüéâ Tous les tests sont satisfaisants!")
    else:
        print("\n‚ö†Ô∏è Certains tests n√©cessitent des am√©liorations.") 